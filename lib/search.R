#######################################################################
###  
###  ## Need to source partner-search-lookup.RData first! ##
###  
###  These are functions for computing search counts for FHR profiles,
###  by search provider name and SAP name, by day or overall for the
###  profile.
###  
###  Search counts should be computed using dailySearchCounts() or
###  totalSearchCounts(). They can return overall sums, or else search 
###  counts over groups of search provider or SAP. Groupings can be 
###  specified in a variety of ways, as explained in the function doc.
###  These functions are applied to the data$days list in the FHR 
###  payload.
###  
###  Each of these functions require applying the function allSearches() 
###  to the data$days list as a preprocessing step. However, it is 
###  usually not necessary to do this explicitly. Passing 
###  'preprocess = TRUE' (the default) in the SearchCounts functions 
###  will apply the preprocessing to the data$days list automatically. 
###  If this is to be applied multiple times to the same active days,
###  it may be better to cache the output of allSearches() first and 
###  use 'preprocess = FALSE'.
###  
###  The second section contains functions for computing daily default
###  search engines, either read from the recorded field, or inferred
###  from searches made on that day.
###  
###  The third section gives some convenience functions for finding
###  search provider names that correspond to official partner searches
###  and major search engines. These can be used to group searches
###  in the SearchCounts functions.    
###  
#######################################################################


## Extracts all search count information from the supplied FHR days list 
## (data$days or a subset, even empty), and packages it 
## into a convenient form.
## 
## This is intended as a preprocessing step for computing search counts
## by search provider and SAP. It parses out provider and SAP strings, 
## and removes values that are considered invalid. 
## 
## Returns a list with an entry for each day that has valid search counts
## (searches.counts entry), or NULL if none are found in the supplied days list.
## Each entry is itself a list, with entries of the form:
## list(provider = character(...), sap = character(...), count = numeric(...)).
## Element i of the vectors give the search provider, SAP, and count 
## corresponding to that day's i-th search count respectively.
allSearches <- function(days) {
    if(length(days) == 0) return(NULL)
    ## Process search info on each day. 
    ## Result will contain NULL entries for each day with no searches.
    sc <- lapply(days, function(d) {
        ## Handle any errors due to bad data on a per-day basis.
        tryCatch({
            s <- d[["org.mozilla.searches.counts"]]
            if(length(s) == 0) return(NULL)
            ## Remove version field if present.
            s[["_v"]] <- NULL
            if(length(s) == 0) return(NULL)
            
            ## Search providers and SAPs are encoded in the element names.
            stypes <- names(s)
            ## Convert counts to numeric vector and remove any invalid entries.
            svals <- trunc(as.numeric(unlist(s, use.names = FALSE)))
            badvals <- is.na(svals) | svals <= 0
            if(all(badvals)) return(NULL)
            if(any(badvals)) {
                ## Make sure to update both values and type strings.
                svals <- svals[!badvals]
                stypes <- stypes[!badvals]
            }
            
            ## Split type strings into SAP and search provider.
            ## Name format should be <searchengine>.<SAP>.
            ## Don't match SAP names exactly (in case they change),
            ## but check that they consist of [a-z] characters.
            ## Split around the last "." character in the string.
            splitinds <- as.integer(regexpr("\\.[a-z]+$", stypes, perl = TRUE))
            badtypes <- splitinds < 0
            if(all(badtypes)) return(NULL)
            if(any(badtypes)) {
                svals <- svals[!badtypes]
                stypes <- stypes[!badtypes]
                splitinds <- splitinds[!badtypes]
            }
            saps <- substr(stypes, splitinds + 1, nchar(stypes))
            spvs <- substr(stypes, 1, splitinds - 1)
            ## Also trim whitespace around search provider name. 
            ## (In particular, some Bing searches are recorded as "Bing ".)
            spvs <- gsub("^\\s+|\\s+$", "", spvs)
            
            list(provider = spvs, sap = saps, count = svals)
        }, error = function(e) { NULL })
    })
    ## Remove NULL entries in days list, indicating days with no valid searches.
    sc.null <- as.logical(lapply(sc, is.null))
    if(all(sc.null)) return(NULL)    
    if(any(sc.null)) return(sc[!sc.null])
    sc
}

## Computes the search counts for a single day's searches (a single entry
## in the list returned by allSearches()), totaled by
## search provider and SAP.
##
## The provider and SAP identifier strings can optionally be grouped, and the
## search counts will be summed over these groups instead of over the raw 
## identifiers. To do this, supply functions to the arguments provider.grouping 
## and sap.grouping. The functions should map a vector of identifier strings to 
## the corresponding group labels that they should be counted under. The default
## grouping is to use all original identifiers.
##
## Either of the provider or SAP dimensions can be ignored entirely in summing,
## ie. all its identifiers are lumped into a single, trivial group, and the 
## results will not include it. To do this, set the appropriate grouping
## argument to NULL. Seting both to NULL means computing overall total searches.
##
## If either of the grouping functions can return NA, the counts for groups
## labelled NA can be removed from the output by setting removeNA = TRUE.
## This can be used to restrict counts to a subset of interest: make the 
## grouping functions return NA for other searches and drop them from the
## output. If there is grouping along both dimensions, this will remove counts
## for which the group labels for either provider or sap is NA. By default,
## NA groups are not removed and are treated the same as the other groups.
##
## The return value depends on which of the provider and SAP dimensions are used
## for counting. If both grouping arguments are NULL, the result is a scalar 
## count of overall total searches for that day. If one grouping argument is 
## NULL, the result is a named vector mapping group names to search counts for 
## that group. If both grouping dimensions are used, the result is a 
## two-dimensional array, with provider groups as row names and SAP groups as 
## column names. If removeNA caused all search counts to be removed, the result
## is NULL.
searchCountValues <- function(searchday, provider.grouping = identity, 
                                    sap.grouping = identity, removeNA = FALSE) {
    ## If both grouping arguments are NULL, just return the total count.
    if(is.null(provider.grouping) && is.null(sap.grouping))
        return(sum(searchday$count))
    ## Otherwise apply grouping and sum over groups..
    groupby <- list()
    if(!is.null(provider.grouping))
        groupby[[length(groupby) + 1]] <- provider.grouping(searchday$provider)
    if(!is.null(sap.grouping))
        groupby[[length(groupby) + 1]] <- sap.grouping(searchday$sap)
    
    if(length(groupby) == 1) {
        ## Case of single dimension.
        ## Use factor levels to exclude NAs if required.
        grouping <- factor(groupby[[1]], exclude = if(removeNA) NA else NULL)
        ## If all groups are NA, nothing to return.
        if(length(levels(grouping)) == 0) return(NULL)
        counts <- split.default(searchday$count, grouping, drop = FALSE)
        counts <- lapply(counts, sum)
        return(setNames(as.numeric(counts), names(counts)))
    }
    
    ## Otherwise, we are in the case of 2 dimensions.
    ## We aggregate counts for SAP groups separately by search provider group.
    ## First find the levels to use for grouping SAPs.
    ## Handle NAs here, and use exclude = NULL later.
    saps <- unique(groupby[[2]])
    if(removeNA) {
        saps.na <- is.na(saps)
        ## If the only SAP group is NA, then no counts will be returned.
        if(all(saps.na)) return(NULL)
        ## Otherwise, we ignore counts for the NA group.
        if(any(saps.na)) saps <- saps[!saps.na]
    }
    ## Find indices corresponding to search provider groups, removing NAs 
    ## if required.
    spvgrouping <- factor(groupby[[1]], exclude = if(removeNA) NA else NULL)
    ## If all groups are NA, nothing to return.
    if(length(levels(spvgrouping)) == 0) return(NULL)
    spvinds <- split.default(seq_along(groupby[[1]]), spvgrouping)
    ## Find search counts by SAP group separately for each provider group.
    spvcounts <- lapply(spvinds, function(inds) {
        ## The levels determine which groups are included in the output.
        sapgrouping <- factor(groupby[[2]][inds], levels = saps, exclude = NULL)
        ## Counts for each level of SAP grouping.
        counts <- split.default(searchday$count[inds], sapgrouping, drop = FALSE)
        ## Empty cells will have a count of 0.
        counts <- lapply(counts, sum)
        setNames(as.numeric(counts), names(counts))
    })
    ## Join counts into a matrix of providers x SAPs.
    countsmat <- do.call(rbind, spvcounts)
    ## Set rownames manually to avoid NAs getting converted to "NA".
    rownames(countsmat) <- names(spvcounts)
    countsmat
}

## Computes daily search counts by search provider and SAP.
##
## Input is either the data$days list (default), or the list returned 
## by allSearches(). The input type should be flagged by setting 'preprocess' 
## to TRUE for the former and FALSE for the latter. 
##
## Search counts can be returned either as overall daily totals, or grouped
## or subsetted by either search provider name or SAP name. This behaviour
## is controlled using the 'provider' and 'sap' arguments. 
##
## In grouping, the search counts will be assigned to groups based on the 
## search providers or SAP string identifiers. The method for assigning groups
## can be specified in a variety of ways, which apply to both 'provider' and 
## 'sap' arguments: 
##  - TRUE, meaning that there will be a separate count for each raw identifier
##    (no grouping). This is the default.
##  - FALSE or NULL, meaning that counts will not be split across this dimension
##    (ie. all values belong to a single, trivial group)
##  - A function which maps a vector of identifiers to group names (or NA)
##  - A list whose names are the group names, and whose elements are
##    either functions or character vectors used to determine membership in
##    the named group. For vectors, searches are assigned to the group if the
##    identifier is listed in the vector. Functions should map a vector of 
##    identifiers to a vector of booleans indicating whether each should be 
##    assigned to that group. 
##    Identifiers that are not assigned to any group by any of these functions 
##    will be assigned to a group named NA. To specify another name for this 
##    "unassigned" group, the list should contain an NA entry whose name is the
##    desired group name. An example of this form is: 
##      list(yahoo = function(v) { grepl("^yahoo", v) }, google = "google", 
##          other = NA).
##  An input in any different form generates an error.
## 
## By default, any searches assigned to a group labelled NA will be treated
## the same as any other group. However, setting removeNA = TRUE will cause
## the NA group to be removed from the output. This can be used for subsetting
## searches. To only count searches belonging to a certain subset of interest, 
## assign the others to a group labelled NA (either explicitly in the function
## form or automatically using the list form), and use removeNA = TRUE. If both
## the provider and sap dimensions have NAs, this will drop counts for which 
## either dimension is NA.
## 
## Returns a list with an entry for each day that has searches (as returned by
## allSearches()), except for days for which all searches were removed by 
## setting removeNA = TRUE. If there are no remaining days, returns NULL.
## Each entry is of the form returned by searchCountValues(), either a scalar
## or a one- or two-dimensional array.
dailySearchCounts <- function(days, provider = TRUE, sap = TRUE, 
                                        removeNA = FALSE, preprocess = TRUE) {
    if(preprocess) days <- allSearches(days)
    if(length(days) == 0) return(NULL)
    searchcounts <- lapply(days, searchCountValues, groupingFunction(provider),
        groupingFunction(sap), removeNA)
    ## Remove any NULLs that were introduced by subsetting.
    if(removeNA) {
        sc.null <- as.logical(lapply(searchcounts, is.null))
        if(all(sc.null)) return(NULL)    
        if(any(sc.null)) return(searchcounts[!sc.null])
    }
    searchcounts
}

## Computes total search counts by search provider and SAP across all days
## in the time period that have searches. 
##
## Arguments are as described for dailySearchCounts().
##
## The return value is the same as that for searchCountValues() 
## (in particular, NULL if no searches are found or retained).
totalSearchCounts <- function(days, provider = TRUE, sap = TRUE, 
                                        removeNA = FALSE, preprocess = TRUE) {
    if(preprocess) days <- allSearches(days)
    if(length(days) == 0) return(NULL)
    flds <- c("provider", "sap", "count")
    searches <- setNames(lapply(flds, function(nn) { 
        unlist(lapply(days, "[[", nn), use.names = FALSE)
    }), flds)
    searchCountValues(searches, groupingFunction(provider), 
        groupingFunction(sap), removeNA)
}


## Generates a function to apply for grouping in searchCountValues()
## based on the various input types accepted by the SearchCounts functions.
groupingFunction <- function(grouping) {
    if(isTRUE(grouping)) return(identity)
    if(is.null(grouping) || identical(grouping, FALSE)) return(NULL)
    if(is.function(grouping)) return(grouping)
    if(is.list(grouping)) {
        if(!all(unlist(lapply(grouping, function(g) { 
            identical(g, NA) || is.function(g) || is.character(g) 
        }))))
            stop("Invalid grouping argument.")
        ## First check if we have a label for the NA group. 
        nagroup <- is.na(grouping)
        nagroupname <- if(any(nagroup)) {
            n <- names(grouping)[nagroup][[1]] 
            grouping <- grouping[!nagroup]
            n
        } else { NA }
        ## Convert character vector inputs to functions for checking membership.
        grouping <- lapply(grouping, function(g) {
            if(is.character(g)) { 
                function(vals) { vals %in% g } 
            } else { g }
        })
        return((function(groupmembers) {
            eval(bquote(function(vals) {
                ## Assign values to each group as appropriate.
                ## Keep track of unassigned values.
                unassigned <- rep_len(TRUE, length(vals))
                for(groupname in names(groupmembers)) {
                    incurrentgroup <- groupmembers[[groupname]](vals)
                    if(!any(incurrentgroup)) next
                    vals[incurrentgroup] <- groupname
                    unassigned <- unassigned & !incurrentgroup
                    if(!any(unassigned)) break
                }
                if(any(unassigned)) vals[unassigned] <- .(unassignedgroupname)
                vals
            }, list(unassignedgroupname = nagroupname)))
        })(grouping))
    }
    ## At this point, the input doesn't match any of the valid forms.
    stop("Invalid grouping argument.")
}


##----------------------------------------------------------------

## Returns a vector mapping dates to the default search engine recorded on 
## that day. Dates with no measurement will not be included in the output.
## If no default engine measurements are found, returns NULL.
dailyDefaultSearchEngines <- function(days) {
    defaults <- unlist(lapply(days, function(d) {
        d$org.mozilla.searches.engines$default
    }))
    if(length(defaults) == 0) return(NULL)
    ## Remove any special values. 
    specialvals <- defaults %in% c("NONE", "UNDEFINED")
    if(all(specialvals)) return(NULL)
    if(any(specialvals)) return(defaults[!specialvals])
    defaults
}

## Infers the default search engine setting for FHR active dates.
## 
## Returns a vector mapping dates to the inferred default search engine name 
## on that date, for each date in the supplied data$days list.
## If 'info' is TRUE, the output is a list rather than a vector, with a list
## for each day with elements:
## - default: the default search engine name
## - inferred: whether the search default was inferred from search counts
## - sameday: whether the search default is based on information observed 
##            on the current day.  
## If 'lastonly' is TRUE, returns the single element corresponding to the most 
## recent date in the 'days' list (a string if 'info' is FALSE, and a list 
## otherwise).
## 
## If the sequence of default search engines has been extracted separately
## using dailyDefaultSearchEngines(), or the raw searches have been processed
## using allSearches(), these can be passed directly to avoid reprocessing,
## using 'defaults' and 'searches' respectively.
##
## The default search engine on a given day is inferred as follows:
## - if there are default search engines recorded on or before the given day, 
##   retain the most recent one.
## - if there are search counts recorded on or before the given day, retain the
##   most recent such day. The default search engine is inferred from the search
##   counts as the most frequently used (raw) search engine on that day, with
##   ties broken at random.
## - if both a recorded default and a default inferred from search counts are
##   available, use the inferred default if it is more recent than the recorded
##   one, and the recorded one otherwise.
## - if only one of the two is available, use that
## - if neither are available, the result is NA.
inferDefaultSearchEngine <- function(days, lastonly = FALSE, info = FALSE,
                                            defaults = NULL, searches = NULL) {
    if(length(days) == 0) return(NULL)
    if(missing(defaults)) defaults <- dailyDefaultSearchEngines(days)
    if(missing(searches)) searches <- allSearches(days)
    dates <- names(days)
    
    ## Function to look up most recent date prior to a given date.
    mostrecentprior <- function(currentdate, referencedates) {
        priordates <- referencedates <= currentdate
        if(any(priordates)) max(referencedates[priordates]) else NULL
    }
    
    ## Set methodology according to which sources of information are available.    
    ## Function to compute the default for a given day.
    inferdefault <- if(length(searches) > 0) {
        ## Compute the inferred default on each search day.
        searches <- inferDailyDefaultFromSearches(searches)
        if(length(defaults) > 0) {
            ## Have information for both.
            function(d) {
                defaultdate <- mostrecentprior(d, names(defaults))
                searchdate <- mostrecentprior(d, names(searches))
                if(is.null(defaultdate)) {
                    ## No recorded default.
                    ## Use inferred, if present.
                    if(is.null(searchdate)) {
                        list(default = NA,
                            inferred = FALSE,
                            sameday = FALSE)
                    } else {
                        list(default = searches[[searchdate]],
                            inferred = TRUE,
                            sameday = searchdate == d)
                    }
                } else {
                    ## If both are present, choose between them.
                    ## Otherwise, use recorded default.
                    if(is.null(searchdate)) { 
                        list(default = defaults[[defaultdate]],
                            inferred = FALSE,
                            sameday = defaultdate == d)
                    } else {
                        ## Have both recorded and inferred default for the 
                        ## current date. Use the recorded default, unless 
                        ## the inferred is more recent.
                        if(searchdate > defaultdate) {
                            list(default = searches[[searchdate]],
                                inferred = TRUE,
                                sameday = searchdate == d)
                        } else {
                            list(default = defaults[[defaultdate]],
                                inferred = FALSE,
                                sameday = defaultdate == d)
                        }
                    }
                }
            }   
        } else {
            ## Only have searches.
            function(d) { 
                searchdate <- mostrecentprior(d, names(searches))
                if(is.null(searchdate)) {
                    list(default = NA,
                        inferred = FALSE,
                        sameday = FALSE)
                } else {
                    list(default = searches[[searchdate]],
                        inferred = TRUE,
                        sameday = searchdate == d)
                }
            }
        }
    } else {
        if(length(defaults) > 0) {
            ## Only have recorded defaults.
            function(d) { 
                defaultdate <- mostrecentprior(d, names(defaults))
                if(is.null(defaultdate)) {
                    list(default = NA,
                        inferred = FALSE,
                        sameday = FALSE)
                } else { 
                    list(default = defaults[[defaultdate]],
                        inferred = FALSE,
                        sameday = defaultdate == d)
                }
            }
        } else {
            ## Have neither searches nor recorded defaults.
            function(d) { 
                list(default = NA,
                    inferred = FALSE,
                    sameday = FALSE)
            }
        }
    }
    if(lastonly) {
        result <- inferdefault(max(dates))
        if(!info) return(result$default)
        return(result)
    }
    result <- setNames(lapply(dates, inferdefault), dates)
    if(!info) return(unlist(lapply(result, "[[", "default")))
    result
}

## Infers daily search defaults for each element in the list of search 
## information returned by allSearches(). The inferred search default is 
## the most frequently used search provider on a given day.
## 
## Returns a named vector the same length as the inputted list, mapping dates 
## to the inferred search default on each day.
inferDailyDefaultFromSearches <- function(searches) {
    unlist(lapply(
        dailySearchCounts(searches, provider = TRUE, sap = FALSE, 
            preprocess = FALSE),
        mostCommonProvider
    ))
        
}

## Computes the most frequently used search provider from a vector of search
## counts. 
## The input should a named vector mapping search provider names to counts.
## Returns the search provider name with the highest count, breaking ties 
## at random.
mostCommonProvider <- function(searchcounts) {
    if(length(searchcounts) == 1) return(names(searchcounts)[[1]])
    searchcounts <- searchcounts[order(names(searchcounts))]
    hasmaxcount <- which(searchcounts == max(searchcounts))
    if(length(hasmaxcount) == 1) 
        return(names(searchcounts)[[hasmaxcount[[1]]]])
    names(searchcounts)[[sample(hasmaxcount, 1)]]
}



##----------------------------------------------------------------

## These functions identify commonly queried search types (ie. searches 
## through major partner search engines), subject to our scheme for
## mapping search provider strings to actual search engines. 
## 
## These can be used to create groups for the *SearchCounts() functions above.
## The argument 'distribtype' in the following functions should be supplied
## the major distribution type or partner as returned by majorDistribValue().


## Returns the list of search provider name strings representing official
## search plugins, optionally restricted to those related to a major search 
## engine.
##
## Currently the results are not specific to locale, so any restrictions to 
## locale would need to be made separately.
## 
## Official search plugins consist of all the plugins included across all 
## stock builds, and may also include certain "other"-prefixed search names 
## on certain partner distributions. Hence, this list should be queried 
## separately for each profile, based on its distribution. 
##
## Official plugins related to major search providers are generally identified
## by full name or prefix which generally matches the partner name (suffixes
## generally indicate localizations). Official plugins related to search partners
## should generally include the prefixed stock plugins, as well as certain
## "other"-prefixed plugins on that partner's builds, if any.
##
## - To find the overall list of official stock plugins, use no arguments.
## - To find the list of plugins considered official for a specific profile,
##   specify the major distribution type (ie. as returned by majorDistribValue())
##   as 'distribtype'. The result will be the full list of stock plugins, 
##   together with any distribution-specific "other"-prefixed plugins that need
##   to be included.
## - To restrict plugins to specific search engines, supply the prefix names
##   for the search engines as 'prefix' (eg. prefix = "yahoo"). This can be a
##   regular expression, and will be interpreted as such (eg. "(a|b)").
##   The prefix will also be checked against the distribtype, if one is supplied.
##   If the distribtype has the same prefix, its plugin names will also be 
##   included. 
searchNamesOfficialAndPartner <- function(distribtype = NULL, prefix = NULL) {
    ## First find the list of official stock plugins, optionally restricted
    ## by prefix.
    searchnames <- if(length(prefix) == 0) { 
        official.plugins 
    } else {
        patterns <- sprintf("^%s", prefix)
        unlist(lapply(patterns, grep, official.plugins, value = TRUE))
    }
    if(length(distribtype) == 0) return(searchnames)
    
    ## Then add plugins coming from relevant partner distributions.
    ## Add any official plugins corresponding to distribtype.
    ## If we are using the prefix restriction, only include plugins from 
    ## distributions related to that prefix.
    if(length(prefix) > 0) {
        patterns <- sprintf("^%s", prefix)
        distribtype <- unlist(lapply(patterns, grep, distribtype, value = TRUE))
    }
    partnersearch <- unlist(partner.plugins[distribtype], use.names = FALSE)
    append(searchnames, sprintf("other-%s", partnersearch))
}

## List of all search provider names considered official plugins for 
## the given distribution type, returned as a character vector.
## Consists of all official stock plugin names and any "other"-prefixed
## names to be included for the specified distribution.
official.searchnames <- function(distribtype) {
    searchNamesOfficialAndPartner(distribtype)
}

## List of all search provider names associated with official Yahoo searches
## for the specified distribution, returned as a character vector.
yahoo.searchnames <- function(distribtype) {
    searchNamesOfficialAndPartner(distribtype, "yahoo")
}

## List of all search provider names associated with official Bing searches
## for the specified distribution, returned as a character vector.
bing.searchnames <- function(distribtype) {
    searchNamesOfficialAndPartner(distribtype, "bing")
}

## List of all search provider names associated with official Google searches
## for the specified distribution, returned as a character vector.
google.searchnames <- function(distribtype) {
    searchNamesOfficialAndPartner(distribtype, "google")
}

## List of all search provider names associated with official Yandex searches
## for the specified distribution, returned as a character vector.
## The list is not locale-specific, as it includes Yandex search engine names
## used across all locales.
yandex.searchnames <- function(distribtype) {
    searchNamesOfficialAndPartner(distribtype, "yandex")
}

## List of all search provider names associated with official Baidu searches
## for the specified distribution, returned as a character vector.
## The list is not locale-specific, as it includes Baidu search engine names
## used across all locales.
baidu.searchnames <- function(distribtype) {
    searchNamesOfficialAndPartner(distribtype, "baidu")
}

## List of all search provider names associated with official Amazon searches
## for the specified distribution, returned as a character vector.
amazon.searchnames <- function(distribtype) {
    searchNamesOfficialAndPartner(distribtype, "amazon")
}

## List of all search provider names associated with official eBay searches
## for the specified distribution, returned as a character vector.
ebay.searchnames <- function(distribtype) {
    searchNamesOfficialAndPartner(distribtype, "eBay")
}

## List of all search provider names associated with official DuckDuckGo
## searches for the specified distribution, returned as a character vector.
duckduckgo.searchnames <- function(distribtype) {
    searchNamesOfficialAndPartner(distribtype, "(ddg|duckduckgo)")
}

## List of all search provider names associated with official AOL searches
## for the specified distribution, returned as a character vector.
aol.searchnames <- function(distribtype) {
    searchNamesOfficialAndPartner(distribtype, "aol")
}

