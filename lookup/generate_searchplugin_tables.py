
""" 
Generate lists of localized search plugins and defaults for Firefox stock
builds.

These are the preloaded search plugins distributed with stock Mozilla builds 
that will be considered "official" when counting searches.

The plugin names are gathered from a localization config file listing preloaded
plugins by locale, app and channel. The following tables are generated based on 
the information in the config file, and saved to CSV files in the current dir.

- A top-level table is generated by locale, separating desktop and mobile. 
There are generally no differences between channels, and plugins are combined 
across channels for each locale. 
- A simplified lookup table is also created listing official plugins 
combined across all locales. This is the list that is used by the FHR lib 
functions to determine which plugins are official. This list combines
plugins across desktop and mobile.
- Finally, the script generates a table of preset default search engines by app 
and locale.
- A record of the date on which the config info was last updated is also 
outputted.
"""

import urllib2
import json
import csv
from operator import itemgetter

# Localization config describing search settings. 
configs_url = 'http://l10n.mozilla-community.org/~flod/p12n/searchplugins.json'

# CSV output files:
# Flat table containing all relevent info from config file on search plugins.
full_info_table = 'full_official_plugin_info.csv'
# Table of preset default plugins for each segement.
default_table = 'official_plugin_defaults.csv'
# Lookup table containing official search plugins to be used in FHR processing.
official_plugin_lookup = 'official_search_plugins.csv'
# File indicating the date to which the information current.
lastupdated_file = 'searchplugins_last_updated'


def search_plugin_list(raw_channel_section):
    """Extract list of search plugins from raw JSON section.
    
    The section should be the info block for a given locale/app/channel 
    combination. Returns a list of tuples of the form (shortname, "fullname"),
    one for each listed search plugin.
    """
    raw_plugins_section = raw_channel_section['searchplugins']
    return [(shortname, '"%s"' % raw_plugins_section[shortname]['name'])
                for shortname in raw_plugins_section]


def search_default(raw_channel_section):
    """Extract the default search plugin from the raw JSON section.
    
    The section should be the info block for a given locale/app/channel 
    combination.
    """
    return '"%s"' % raw_channel_section['p12n']['defaultenginename']


def combine_plugins_across_channels(raw_app_section, locale, appname):
    """Combine lists of search plugins across channels for a given app/locale.
    
    The config file lists sets of preloaded search plugins separately by 
    channel, although these will generally be identical. Combine these into a 
    single list of search plugins, and print a warning if some channels had
    different preloaded search plugins.
    """
    # First find the collection of unique plugin lists across channels.
    sp_by_channel = set()
    for channel_info in raw_app_section.itervalues():
        sp_list = search_plugin_list(channel_info)
        sp_list.sort()
        sp_by_channel.add(tuple(sp_list))
    if len(sp_by_channel) > 1:
        # Some channels have different lists.
        # Print message and combine.
        print(('\n* Different channels have different search plugin lists for' +
            ' %s in %s:' % (appname, locale)))
        for sp_list in sp_by_channel:
            print(', '.join(['%s (%s)' % (sp[0], sp[1]) for sp in sp_list]))
        # Find the overall collection of unique plugins from the union of 
        # the plugin lists.
        sp_by_channel = [set(sp_list) for sp_list in sp_by_channel]
        sp_deduped = reduce(set.union, sp_by_channel)
        final_list = sorted(sp_deduped)
    else:
        # There was only one unique list.
        final_list = sp_by_channel.pop()
    return final_list


def combine_defaults_across_channels(raw_app_section, locale, appname):    
    """Combine default search plugins across channels for a given app/locale.
    
    The config file lists preset default search plugins separately by 
    channel, although these will generally be identical. If they are not, 
    return the default listed for release and print a warning. Otherwise,
    return the common default plugin.
    """
    # Find the collection of unique search defaults across channels.
    dsp_by_channel = map(search_default, raw_app_section.itervalues())
    dsp_by_channel = set(dsp_by_channel)
    if len(dsp_by_channel) > 1:
        # There are different search defaults across channels.
        # Print message.
        print(('\n* Different channels have different default search plugins' +
            ' for %s in %s:' % (appname, locale)))
        print(', '.join(dsp_by_channel))
        # Use the default listed for release.
        final_dsp = search_default(raw_app_section['release'])
    else:
        # There is only one common default.
        final_dsp = dsp_by_channel.pop()
    return final_dsp


def encode_row(row):
    """Encode values in CSV row prior to writing."""
    return [v.encode('utf-8', 'backslashreplace') for v in row]


def main():
    """ Download configs file and extract search plugins information.
    
    Organize into tables and output as CSV. Also store the JSON creation date.
    """
    configs_json = json.load(urllib2.urlopen(configs_url))
    creation_date = configs_json['metadata']['creation_date']
    configs_json = configs_json['locales']
    # Collect plugins and defaults keyed by (locale, appp).
    plugin_lists = {}
    default_plugins = {}
    
    # Extract the lists of preset plugins and defaults for each app and locale.
    for locale, locale_section in configs_json.iteritems():
        for appname in ('browser', 'mobile'):
            app_section = locale_section.get(appname)
            if not app_section:
                continue
            config_key = (locale, 'desktop' if appname == 'browser' else appname)
            plugin_lists[config_key] = (
                combine_plugins_across_channels(app_section, locale, appname))
            default_plugins[config_key] = (
                combine_defaults_across_channels(app_section, locale, appname))
    
    # Generate CSV tables.
    # Print flattened verison of plugin_lists. 
    with open(full_info_table, 'w') as f:
        w = csv.writer(f)
        w.writerow(['app', 'locale', 'shortname', 'fullname'])
        # Run through plugins ordered by app then locale.
        config_keys = plugin_lists.keys()
        config_keys.sort(key = itemgetter(1,0))
        for k in config_keys:
            for sp in plugin_lists[k]:
                encoded_row = encode_row([k[1], k[0], sp[0], sp[1]])
                w.writerow(encoded_row)
    
    # Print lookup table of official plugins.
    # These are the union of plugins across apps and locales.
    official_plugins = [set(v) for v in plugin_lists.itervalues()]
    official_plugins = reduce(set.union, official_plugins)
    with open(official_plugin_lookup, 'w') as f:
        w = csv.writer(f)
        w.writerow(['shortname', 'fullname'])
        for sp in sorted(official_plugins):
            w.writerow(encode_row([sp[0], sp[1]]))
    
    # Print flattened list of search defaults.
    with open(default_table, 'w') as f:
        w = csv.writer(f)
        w.writerow(['app', 'locale', 'default'])
        # Run through plugins ordered by app then locale.
        config_keys = default_plugins.keys()
        config_keys.sort(key = itemgetter(1,0))
        for k in config_keys:
            w.writerow(encode_row([k[1], k[0], default_plugins[k]]))
    
    # Save the creation date of the JSON.
    with open(lastupdated_file, 'w') as f:
        f.write(creation_date)


if __name__ == '__main__':
    main()
